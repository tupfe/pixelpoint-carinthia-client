"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateComponent = generateComponent;
exports.generateElement = generateElement;
const CompilerDOM = require("@vue/compiler-dom");
const shared_1 = require("@vue/shared");
const muggle_string_1 = require("muggle-string");
const shared_2 = require("../../utils/shared");
const codeFeatures_1 = require("../codeFeatures");
const inlayHints_1 = require("../inlayHints");
const names = require("../names");
const utils_1 = require("../utils");
const boundary_1 = require("../utils/boundary");
const camelized_1 = require("../utils/camelized");
const elementDirectives_1 = require("./elementDirectives");
const elementEvents_1 = require("./elementEvents");
const elementProps_1 = require("./elementProps");
const interpolation_1 = require("./interpolation");
const propertyAccess_1 = require("./propertyAccess");
const styleScopedClasses_1 = require("./styleScopedClasses");
const templateChild_1 = require("./templateChild");
const vSlot_1 = require("./vSlot");
const colonReg = /:/g;
function* generateComponent(options, ctx, node) {
    const tagOffsets = (0, shared_2.getElementTagOffsets)(node, options.template);
    const failGeneratedExpressions = [];
    const possibleOriginalNames = getPossibleOriginalComponentNames(node.tag, true);
    const matchConst = possibleOriginalNames.find(name => options.setupConsts.has(name));
    const componentOriginalVar = matchConst ?? ctx.getInternalVariable();
    const componentFunctionalVar = ctx.getInternalVariable();
    const componentVNodeVar = ctx.getInternalVariable();
    const componentCtxVar = ctx.getInternalVariable();
    const componentPropsVar = ctx.getInternalVariable();
    const isComponentTag = node.tag.toLowerCase() === 'component';
    let isCtxVarUsed = false;
    let isPropsVarUsed = false;
    ctx.currentComponent = {
        get ctxVar() {
            isCtxVarUsed = true;
            return componentCtxVar;
        },
        get propsVar() {
            isPropsVarUsed = true;
            return componentPropsVar;
        },
    };
    let props = node.props;
    let dynamicTagInfo;
    if (isComponentTag) {
        for (const prop of node.props) {
            if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE
                && prop.name === 'bind'
                && prop.arg?.loc.source === 'is'
                && prop.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION) {
                if (prop.arg.loc.end.offset === prop.exp.loc.end.offset) {
                    ctx.inlayHints.push((0, inlayHints_1.createVBindShorthandInlayHintInfo)(prop.exp.loc, 'is'));
                }
                dynamicTagInfo = {
                    tag: prop.exp.content,
                    offsets: [prop.exp.loc.start.offset],
                };
                props = props.filter(p => p !== prop);
                break;
            }
        }
    }
    else if (node.tag.includes('.')) {
        // namespace tag
        dynamicTagInfo = {
            tag: node.tag,
            offsets: tagOffsets,
        };
    }
    if (matchConst) {
        // navigation support
        yield `/** @type {[`;
        for (const tagOffset of tagOffsets) {
            yield `typeof `;
            if (componentOriginalVar === node.tag) {
                yield [
                    componentOriginalVar,
                    'template',
                    tagOffset,
                    codeFeatures_1.codeFeatures.withoutHighlightAndCompletion,
                ];
            }
            else {
                const shouldCapitalize = matchConst[0].toUpperCase() === matchConst[0];
                yield* (0, camelized_1.generateCamelized)(shouldCapitalize ? (0, shared_1.capitalize)(node.tag) : node.tag, 'template', tagOffset, codeFeatures_1.codeFeatures.withoutHighlightAndCompletion);
            }
            yield `, `;
        }
        yield `]} */${utils_1.endOfLine}`;
        // auto import support
        yield `// @ts-ignore${utils_1.newLine}`; // #2304
        yield* (0, camelized_1.generateCamelized)((0, shared_1.capitalize)(node.tag), 'template', tagOffsets[0], codeFeatures_1.codeFeatures.importCompletionOnly);
        yield utils_1.endOfLine;
    }
    else if (dynamicTagInfo) {
        yield `const ${componentOriginalVar} = (`;
        yield* (0, interpolation_1.generateInterpolation)(options, ctx, options.template, codeFeatures_1.codeFeatures.all, dynamicTagInfo.tag, dynamicTagInfo.offsets[0], `(`, `)`);
        if (dynamicTagInfo.offsets[1] !== undefined) {
            yield `,`;
            yield* (0, interpolation_1.generateInterpolation)(options, ctx, options.template, codeFeatures_1.codeFeatures.withoutCompletion, dynamicTagInfo.tag, dynamicTagInfo.offsets[1], `(`, `)`);
        }
        yield `)${utils_1.endOfLine}`;
    }
    else {
        yield `const ${componentOriginalVar} = ({} as __VLS_WithComponent<'${getCanonicalComponentName(node.tag)}', __VLS_LocalComponents, `;
        if (options.selfComponentName && possibleOriginalNames.includes(options.selfComponentName)) {
            yield `typeof ${names._export}, `;
        }
        else {
            yield `void, `;
        }
        yield getPossibleOriginalComponentNames(node.tag, false)
            .map(name => `'${name}'`)
            .join(`, `);
        yield `>).`;
        yield* generateCanonicalComponentName(node.tag, tagOffsets[0], {
            ...codeFeatures_1.codeFeatures.semanticWithoutHighlight,
            ...options.vueCompilerOptions.checkUnknownComponents
                ? codeFeatures_1.codeFeatures.verification
                : codeFeatures_1.codeFeatures.doNotReportTs2339AndTs2551,
        });
        yield utils_1.endOfLine;
        const camelizedTag = (0, shared_1.camelize)(node.tag);
        if (utils_1.identifierRegex.test(camelizedTag)) {
            // navigation support
            yield `/** @type {[`;
            for (const tagOffset of tagOffsets) {
                for (const shouldCapitalize of (node.tag[0] === node.tag[0].toUpperCase() ? [false] : [true, false])) {
                    yield `typeof ${names.components}.`;
                    yield* (0, camelized_1.generateCamelized)(shouldCapitalize ? (0, shared_1.capitalize)(node.tag) : node.tag, 'template', tagOffset, codeFeatures_1.codeFeatures.navigation);
                    yield `, `;
                }
            }
            yield `]} */${utils_1.endOfLine}`;
            // auto import support
            yield `// @ts-ignore${utils_1.newLine}`; // #2304
            yield* (0, camelized_1.generateCamelized)((0, shared_1.capitalize)(node.tag), 'template', tagOffsets[0], codeFeatures_1.codeFeatures.importCompletionOnly);
            yield utils_1.endOfLine;
        }
    }
    const propCodes = [...(0, elementProps_1.generateElementProps)(options, ctx, node, props, options.vueCompilerOptions.checkUnknownProps, failGeneratedExpressions)];
    yield `// @ts-ignore${utils_1.newLine}`;
    yield `const ${componentFunctionalVar} = __VLS_asFunctionalComponent(${componentOriginalVar}, new ${componentOriginalVar}({${utils_1.newLine}`;
    yield* (0, muggle_string_1.toString)(propCodes);
    yield `}))${utils_1.endOfLine}`;
    yield `const `;
    const token = yield* (0, boundary_1.startBoundary)('template', node.loc.start.offset, codeFeatures_1.codeFeatures.doNotReportTs6133);
    yield componentVNodeVar;
    yield (0, boundary_1.endBoundary)(token, node.loc.end.offset);
    yield ` = ${componentFunctionalVar}`;
    yield* generateComponentGeneric(ctx);
    yield `(`;
    const token2 = yield* (0, boundary_1.startBoundary)('template', tagOffsets[0], codeFeatures_1.codeFeatures.verification);
    yield `{${utils_1.newLine}`;
    yield* propCodes;
    yield `}`;
    yield (0, boundary_1.endBoundary)(token2, tagOffsets[0] + node.tag.length);
    yield `, ...__VLS_functionalComponentArgsRest(${componentFunctionalVar}))${utils_1.endOfLine}`;
    yield* generateFailedExpressions(options, ctx, failGeneratedExpressions);
    yield* (0, elementEvents_1.generateElementEvents)(options, ctx, node, componentOriginalVar);
    yield* (0, elementDirectives_1.generateElementDirectives)(options, ctx, node);
    const templateRef = getTemplateRef(node);
    const tag = (0, shared_2.hyphenateTag)(node.tag);
    const isRootNode = ctx.singleRootNodes.has(node)
        && !options.vueCompilerOptions.fallthroughComponentNames.includes(tag);
    if (templateRef || isRootNode) {
        const componentInstanceVar = ctx.getInternalVariable();
        isCtxVarUsed = true;
        yield `var ${componentInstanceVar} = {} as (Parameters<NonNullable<typeof ${componentCtxVar}['expose']>>[0] | null)`;
        if (ctx.inVFor) {
            yield `[]`;
        }
        yield utils_1.endOfLine;
        if (templateRef) {
            const typeExp = `typeof ${ctx.getHoistVariable(componentInstanceVar)}`;
            ctx.addTemplateRef(templateRef[0], typeExp, templateRef[1]);
        }
        if (isRootNode) {
            ctx.singleRootElTypes.add(`NonNullable<typeof ${componentInstanceVar}>['$el']`);
        }
    }
    if (hasVBindAttrs(options, ctx, node)) {
        ctx.inheritedAttrVars.add(componentPropsVar);
        isPropsVarUsed = true;
    }
    yield* generateStyleScopedClassReferences(options, node);
    const slotDir = node.props.find(p => p.type === CompilerDOM.NodeTypes.DIRECTIVE && p.name === 'slot');
    yield* (0, vSlot_1.generateVSlot)(options, ctx, node, slotDir);
    if (isCtxVarUsed) {
        yield `var ${componentCtxVar}!: __VLS_FunctionalComponentCtx<typeof ${componentOriginalVar}, typeof ${componentVNodeVar}>${utils_1.endOfLine}`;
    }
    if (isPropsVarUsed) {
        yield `var ${componentPropsVar}!: __VLS_FunctionalComponentProps<typeof ${componentOriginalVar}, typeof ${componentVNodeVar}>${utils_1.endOfLine}`;
    }
}
function* generateElement(options, ctx, node) {
    const [startTagOffset, endTagOffset] = (0, shared_2.getElementTagOffsets)(node, options.template);
    const failedPropExps = [];
    yield `__VLS_asFunctionalElement(${names.intrinsics}`;
    yield* (0, propertyAccess_1.generatePropertyAccess)(options, ctx, node.tag, startTagOffset, codeFeatures_1.codeFeatures.withoutHighlightAndCompletion);
    if (endTagOffset !== undefined) {
        yield `, `;
        yield names.intrinsics;
        yield* (0, propertyAccess_1.generatePropertyAccess)(options, ctx, node.tag, endTagOffset, codeFeatures_1.codeFeatures.withoutHighlightAndCompletion);
    }
    yield `)(`;
    const token = yield* (0, boundary_1.startBoundary)('template', startTagOffset, codeFeatures_1.codeFeatures.verification);
    yield `{${utils_1.newLine}`;
    yield* (0, elementProps_1.generateElementProps)(options, ctx, node, node.props, options.vueCompilerOptions.checkUnknownProps, failedPropExps);
    yield `}`;
    yield (0, boundary_1.endBoundary)(token, startTagOffset + node.tag.length);
    yield `)${utils_1.endOfLine}`;
    yield* generateFailedExpressions(options, ctx, failedPropExps);
    yield* (0, elementDirectives_1.generateElementDirectives)(options, ctx, node);
    const templateRef = getTemplateRef(node);
    if (templateRef) {
        let typeExp = `__VLS_Elements['${node.tag}']`;
        if (ctx.inVFor) {
            typeExp += `[]`;
        }
        ctx.addTemplateRef(templateRef[0], typeExp, templateRef[1]);
    }
    if (ctx.singleRootNodes.has(node)) {
        ctx.singleRootElTypes.add(`__VLS_Elements['${node.tag}']`);
    }
    if (hasVBindAttrs(options, ctx, node)) {
        ctx.inheritedAttrVars.add(`__VLS_intrinsics.${node.tag}`);
    }
    yield* generateStyleScopedClassReferences(options, node);
    const { currentComponent } = ctx;
    ctx.currentComponent = undefined;
    for (const child of node.children) {
        yield* (0, templateChild_1.generateTemplateChild)(options, ctx, child);
    }
    ctx.currentComponent = currentComponent;
}
function* generateStyleScopedClassReferences({ template, ts }, node) {
    for (const prop of node.props) {
        if (prop.type === CompilerDOM.NodeTypes.ATTRIBUTE
            && prop.name === 'class'
            && prop.value) {
            if (template.lang === 'pug') {
                const getClassOffset = Reflect.get(prop.value.loc.start, 'getClassOffset');
                const content = prop.value.loc.source.slice(1, -1);
                for (const [className, pos] of forEachClassName(content)) {
                    yield* (0, styleScopedClasses_1.generateStyleScopedClassReference)(template, className, getClassOffset(pos + 1));
                }
            }
            else {
                const [text, start] = (0, shared_2.normalizeAttributeValue)(prop.value);
                for (const [className, offset] of forEachClassName(text)) {
                    yield* (0, styleScopedClasses_1.generateStyleScopedClassReference)(template, className, start + offset);
                }
            }
        }
        else if (prop.type === CompilerDOM.NodeTypes.DIRECTIVE
            && prop.arg?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION
            && prop.exp?.type === CompilerDOM.NodeTypes.SIMPLE_EXPRESSION
            && prop.arg.content === 'class') {
            const content = '(' + prop.exp.content + ')';
            const startOffset = prop.exp.loc.start.offset - 1;
            const ast = (0, utils_1.getTypeScriptAST)(ts, template, content);
            const literals = [];
            for (const node of (0, utils_1.forEachNode)(ts, ast)) {
                if (!ts.isExpressionStatement(node)
                    || !ts.isParenthesizedExpression(node.expression)) {
                    continue;
                }
                const { expression } = node.expression;
                if (ts.isStringLiteralLike(expression)) {
                    literals.push(expression);
                }
                else if (ts.isArrayLiteralExpression(expression)) {
                    yield* walkArrayLiteral(expression);
                }
                else if (ts.isObjectLiteralExpression(expression)) {
                    yield* walkObjectLiteral(expression);
                }
            }
            for (const literal of literals) {
                const start = literal.end - literal.text.length - 1 + startOffset;
                for (const [className, offset] of forEachClassName(literal.text)) {
                    yield* (0, styleScopedClasses_1.generateStyleScopedClassReference)(template, className, start + offset);
                }
            }
            function* walkArrayLiteral(node) {
                const { elements } = node;
                for (const element of elements) {
                    if (ts.isStringLiteralLike(element)) {
                        literals.push(element);
                    }
                    else if (ts.isObjectLiteralExpression(element)) {
                        yield* walkObjectLiteral(element);
                    }
                }
            }
            function* walkObjectLiteral(node) {
                const { properties } = node;
                for (const property of properties) {
                    if (ts.isPropertyAssignment(property)) {
                        const { name } = property;
                        if (ts.isIdentifier(name)) {
                            yield* (0, styleScopedClasses_1.generateStyleScopedClassReference)(template, name.text, name.end - name.text.length + startOffset);
                        }
                        else if (ts.isStringLiteral(name)) {
                            literals.push(name);
                        }
                        else if (ts.isComputedPropertyName(name)) {
                            const { expression } = name;
                            if (ts.isStringLiteralLike(expression)) {
                                literals.push(expression);
                            }
                        }
                    }
                    else if (ts.isShorthandPropertyAssignment(property)) {
                        yield* (0, styleScopedClasses_1.generateStyleScopedClassReference)(template, property.name.text, property.name.end - property.name.text.length + startOffset);
                    }
                }
            }
        }
    }
}
function* forEachClassName(content) {
    let offset = 0;
    for (const className of content.split(' ')) {
        yield [className, offset];
        offset += className.length + 1;
    }
}
function* generateFailedExpressions(options, ctx, failGeneratedExpressions) {
    for (const failedExp of failGeneratedExpressions) {
        yield* (0, interpolation_1.generateInterpolation)(options, ctx, options.template, codeFeatures_1.codeFeatures.all, failedExp.node.loc.source, failedExp.node.loc.start.offset, failedExp.prefix, failedExp.suffix);
        yield utils_1.endOfLine;
    }
}
function getCanonicalComponentName(tagText) {
    return utils_1.identifierRegex.test(tagText)
        ? tagText
        : (0, shared_1.capitalize)((0, shared_1.camelize)(tagText.replace(colonReg, '-')));
}
function getPossibleOriginalComponentNames(tagText, deduplicate) {
    const name1 = (0, shared_1.capitalize)((0, shared_1.camelize)(tagText));
    const name2 = (0, shared_1.camelize)(tagText);
    const name3 = tagText;
    const names = [name1];
    if (!deduplicate || name2 !== name1) {
        names.push(name2);
    }
    if (!deduplicate || name3 !== name2) {
        names.push(name3);
    }
    return names;
}
function* generateCanonicalComponentName(tagText, offset, features) {
    if (utils_1.identifierRegex.test(tagText)) {
        yield [tagText, 'template', offset, features];
    }
    else {
        yield* (0, camelized_1.generateCamelized)((0, shared_1.capitalize)(tagText.replace(colonReg, '-')), 'template', offset, features);
    }
}
function* generateComponentGeneric(ctx) {
    if (ctx.currentInfo.generic) {
        const { content, offset } = ctx.currentInfo.generic;
        const token = yield* (0, boundary_1.startBoundary)('template', offset, codeFeatures_1.codeFeatures.verification);
        yield `<`;
        yield [content, 'template', offset, codeFeatures_1.codeFeatures.all];
        yield `>`;
        yield (0, boundary_1.endBoundary)(token, offset + content.length);
    }
}
function getTemplateRef(node) {
    for (const prop of node.props) {
        if (prop.type === CompilerDOM.NodeTypes.ATTRIBUTE
            && prop.name === 'ref'
            && prop.value) {
            return (0, shared_2.normalizeAttributeValue)(prop.value);
        }
    }
}
function hasVBindAttrs(options, ctx, node) {
    return options.vueCompilerOptions.fallthroughAttributes && ((options.inheritAttrs && ctx.singleRootNodes.has(node))
        || node.props.some(prop => prop.type === CompilerDOM.NodeTypes.DIRECTIVE
            && prop.name === 'bind'
            && prop.exp?.loc.source === '$attrs'));
}
//# sourceMappingURL=element.js.map